<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å›¾ç‰‡ç¼–è¾‘å™¨</title>
    <link rel="icon" type="image/png" href="/img/48.png" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        background: #f5f5f5;
        overflow: hidden;
      }

      .editor-container {
        display: flex;
        height: 100vh;
        background: white;
      }

      .sidebar {
        width: 280px;
        background: #2a2a2a;
        color: white;
        padding: 20px;
        overflow-y: auto;
      }

      .sidebar h2 {
        font-size: 18px;
        margin-bottom: 20px;
        color: #fff;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }

      .tool-group {
        margin-bottom: 30px;
      }

      .tool-group h3 {
        font-size: 14px;
        color: #bbb;
        margin-bottom: 15px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .tool-btn {
        display: block;
        width: 100%;
        padding: 12px;
        margin-bottom: 8px;
        background: #3a3a3a;
        border: none;
        color: white;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: left;
        font-size: 14px;
      }

      .tool-btn:hover {
        background: #4a4a4a;
      }

      .tool-btn.active {
        background: #667eea;
      }

      .tool-btn .icon {
        display: inline-block;
        width: 20px;
        margin-right: 8px;
        text-align: center;
      }

      .slider-group {
        margin-bottom: 20px;
      }

      .slider-group label {
        display: block;
        font-size: 12px;
        color: #bbb;
        margin-bottom: 5px;
      }

      .slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #4a4a4a;
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #667eea;
        cursor: pointer;
      }

      .slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #667eea;
        cursor: pointer;
        border: none;
      }

      .slider-value {
        float: right;
        font-size: 12px;
        color: #999;
      }

      .filter-btn {
        display: inline-block;
        padding: 8px 12px;
        margin: 4px;
        background: #3a3a3a;
        border: none;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
      }

      .filter-btn:hover {
        background: #4a4a4a;
      }

      .filter-btn.active {
        background: #667eea;
      }

      .main-area {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .toolbar {
        height: 60px;
        background: #f8f9fa;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        align-items: center;
        padding: 0 20px;
        gap: 15px;
      }

      .toolbar button {
        padding: 8px 16px;
        border: 1px solid #ced4da;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s ease;
      }

      .toolbar button:hover {
        background: #e9ecef;
      }

      .toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .toolbar input[type='file'] {
        display: none;
      }

      .canvas-container {
        flex: 1;
        position: relative;
        overflow: auto;
        background: #e9ecef;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .canvas-wrapper {
        position: relative;
        background: white;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
        overflow: hidden;
      }

      #editor-canvas {
        display: block;
        cursor: crosshair;
      }

      .upload-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.9);
        z-index: 10;
      }

      .upload-content {
        text-align: center;
        padding: 40px;
        border: 2px dashed #ccc;
        border-radius: 8px;
        background: white;
      }

      .upload-content h3 {
        margin-bottom: 10px;
        color: #495057;
      }

      .upload-content p {
        color: #6c757d;
        margin-bottom: 20px;
      }

      .upload-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
      }

      .upload-btn:hover {
        background: #5a6fd8;
      }

      .color-picker-container {
        margin-bottom: 20px;
      }

      .color-picker {
        width: 100%;
        height: 40px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .brush-size-container {
        margin-bottom: 20px;
      }

      .brush-preview {
        width: 40px;
        height: 40px;
        background: #4a4a4a;
        border-radius: 50%;
        margin: 10px auto;
        border: 2px solid #667eea;
      }

      .text-controls {
        display: none;
        margin-bottom: 20px;
      }

      .text-controls.active {
        display: block;
      }

      .text-input {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #4a4a4a;
        background: #3a3a3a;
        color: white;
        border-radius: 4px;
      }

      .font-size-input {
        width: 100%;
        padding: 8px;
        border: 1px solid #4a4a4a;
        background: #3a3a3a;
        color: white;
        border-radius: 4px;
      }

      .status-bar {
        height: 30px;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
        display: flex;
        align-items: center;
        padding: 0 20px;
        font-size: 12px;
        color: #6c757d;
      }

      .zoom-controls {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .zoom-btn {
        padding: 4px 8px;
        border: 1px solid #ced4da;
        background: white;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
      }

      .zoom-btn:hover {
        background: #e9ecef;
      }

      @media (max-width: 768px) {
        .sidebar {
          width: 240px;
        }

        .toolbar {
          padding: 0 10px;
          gap: 10px;
        }

        .toolbar button {
          padding: 6px 12px;
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="editor-container">
      <!-- Sidebar -->
      <div class="sidebar">
        <h2>âœ‚ï¸ å›¾ç‰‡ç¼–è¾‘å™¨</h2>

        <!-- Tools -->
        <div class="tool-group">
          <h3>å·¥å…·</h3>
          <button class="tool-btn active" data-tool="select">
            <span class="icon">ğŸ‘†</span>
            é€‰æ‹©
          </button>
          <button class="tool-btn" data-tool="crop">
            <span class="icon">âœ‚ï¸</span>
            è£å‰ª
          </button>
          <button class="tool-btn" data-tool="brush">
            <span class="icon">ğŸ–Œï¸</span>
            ç”»ç¬”
          </button>
          <button class="tool-btn" data-tool="text">
            <span class="icon">ğŸ“</span>
            æ–‡å­—
          </button>
          <button class="tool-btn" data-tool="rectangle">
            <span class="icon">â¬œ</span>
            çŸ©å½¢
          </button>
          <button class="tool-btn" data-tool="circle">
            <span class="icon">â­•</span>
            åœ†å½¢
          </button>
          <button class="tool-btn" data-tool="eraser">
            <span class="icon">ğŸ§½</span>
            æ©¡çš®æ“¦
          </button>
        </div>

        <!-- Color Picker -->
        <div class="tool-group">
          <h3>é¢œè‰²</h3>
          <div class="color-picker-container">
            <input type="color" id="color-picker" class="color-picker" value="#000000" />
          </div>
        </div>

        <!-- Brush Size -->
        <div class="tool-group">
          <h3>ç”»ç¬”å¤§å°</h3>
          <div class="brush-size-container">
            <div class="slider-group">
              <label for="brush-size">
                å¤§å°
                <span class="slider-value" id="brush-size-value">10</span>
              </label>
              <input type="range" id="brush-size" class="slider" min="1" max="50" value="10" />
            </div>
            <div class="brush-preview" id="brush-preview"></div>
          </div>
        </div>

        <!-- Text Controls -->
        <div class="tool-group">
          <h3>æ–‡å­—</h3>
          <div class="text-controls" id="text-controls">
            <input type="text" id="text-input" class="text-input" placeholder="è¾“å…¥æ–‡å­—..." />
            <input
              type="number"
              id="font-size"
              class="font-size-input"
              value="24"
              min="8"
              max="100"
              placeholder="å­—ä½“å¤§å°"
            />
          </div>
        </div>

        <!-- Adjustments -->
        <div class="tool-group">
          <h3>è°ƒæ•´</h3>
          <div class="slider-group">
            <label for="brightness">
              äº®åº¦
              <span class="slider-value" id="brightness-value">0</span>
            </label>
            <input type="range" id="brightness" class="slider" min="-100" max="100" value="0" />
          </div>
          <div class="slider-group">
            <label for="contrast">
              å¯¹æ¯”åº¦
              <span class="slider-value" id="contrast-value">0</span>
            </label>
            <input type="range" id="contrast" class="slider" min="-100" max="100" value="0" />
          </div>
          <div class="slider-group">
            <label for="saturation">
              é¥±å’Œåº¦
              <span class="slider-value" id="saturation-value">0</span>
            </label>
            <input type="range" id="saturation" class="slider" min="-100" max="100" value="0" />
          </div>
          <div class="slider-group">
            <label for="hue">
              è‰²ç›¸
              <span class="slider-value" id="hue-value">0</span>
            </label>
            <input type="range" id="hue" class="slider" min="-180" max="180" value="0" />
          </div>
        </div>

        <!-- Filters -->
        <div class="tool-group">
          <h3>æ»¤é•œ</h3>
          <button class="filter-btn active" data-filter="none">åŸå›¾</button>
          <button class="filter-btn" data-filter="grayscale">ç°åº¦</button>
          <button class="filter-btn" data-filter="sepia">å¤å¤</button>
          <button class="filter-btn" data-filter="blur">æ¨¡ç³Š</button>
          <button class="filter-btn" data-filter="sharpen">é”åŒ–</button>
          <button class="filter-btn" data-filter="vintage">æ€€æ—§</button>
        </div>
      </div>

      <!-- Main Area -->
      <div class="main-area">
        <!-- Toolbar -->
        <div class="toolbar">
          <button id="open-btn">ğŸ“ æ‰“å¼€</button>
          <input type="file" id="file-input" accept="image/*" />
          <button id="save-btn" disabled>ğŸ’¾ ä¿å­˜</button>
          <button id="undo-btn" disabled>â†¶ æ’¤é”€</button>
          <button id="redo-btn" disabled>â†· é‡åš</button>
          <button id="reset-btn" disabled>ğŸ”„ é‡ç½®</button>
          <button id="crop-apply-btn" style="display: none">âœ… åº”ç”¨è£å‰ª</button>
          <button id="crop-cancel-btn" style="display: none">âŒ å–æ¶ˆè£å‰ª</button>
        </div>

        <!-- Canvas Container -->
        <div class="canvas-container">
          <div class="canvas-wrapper">
            <canvas id="editor-canvas" width="800" height="600"></canvas>
          </div>

          <!-- Upload Overlay -->
          <div class="upload-overlay" id="upload-overlay">
            <div class="upload-content">
              <h3>ğŸ“¸ å¼€å§‹ç¼–è¾‘å›¾ç‰‡</h3>
              <p>æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é€‰æ‹©æ–‡ä»¶</p>
              <button class="upload-btn" id="upload-btn">é€‰æ‹©å›¾ç‰‡</button>
            </div>
          </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
          <span id="image-info">å‡†å¤‡å°±ç»ª</span>
          <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-out">âˆ’</button>
            <span id="zoom-level">100%</span>
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-fit">é€‚åº”</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      class ImageEditor {
        constructor() {
          this.canvas = document.getElementById('editor-canvas')
          this.ctx = this.canvas.getContext('2d')
          this.originalImageData = null
          this.currentImageData = null
          this.history = []
          this.historyIndex = -1
          this.currentTool = 'select'
          this.isDrawing = false
          this.lastX = 0
          this.lastY = 0
          this.cropStart = null
          this.cropEnd = null
          this.isCropping = false
          this.zoomLevel = 1

          this.init()
        }

        init() {
          this.setupEventListeners()
          this.updateBrushPreview()
          this.updateUI()
        }

        setupEventListeners() {
          // File input
          document.getElementById('open-btn').addEventListener('click', () => {
            document.getElementById('file-input').click()
          })

          document.getElementById('upload-btn').addEventListener('click', () => {
            document.getElementById('file-input').click()
          })

          document.getElementById('file-input').addEventListener('change', e => {
            this.loadImage(e.target.files[0])
          })

          // Toolbar buttons
          document.getElementById('save-btn').addEventListener('click', () => this.saveImage())
          document.getElementById('undo-btn').addEventListener('click', () => this.undo())
          document.getElementById('redo-btn').addEventListener('click', () => this.redo())
          document.getElementById('reset-btn').addEventListener('click', () => this.reset())
          document
            .getElementById('crop-apply-btn')
            .addEventListener('click', () => this.applyCrop())
          document
            .getElementById('crop-cancel-btn')
            .addEventListener('click', () => this.cancelCrop())

          // Tool buttons
          document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => this.selectTool(btn.dataset.tool))
          })

          // Filter buttons
          document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => this.applyFilter(btn.dataset.filter))
          })

          // Sliders
          ;['brightness', 'contrast', 'saturation', 'hue', 'brush-size'].forEach(id => {
            const slider = document.getElementById(id)
            const valueEl = document.getElementById(id + '-value')

            slider.addEventListener('input', e => {
              valueEl.textContent = e.target.value
              if (id === 'brush-size') {
                this.updateBrushPreview()
              } else {
                this.applyAdjustments()
              }
            })
          })

          // Canvas events
          this.canvas.addEventListener('mousedown', e => this.startDrawing(e))
          this.canvas.addEventListener('mousemove', e => this.draw(e))
          this.canvas.addEventListener('mouseup', () => this.stopDrawing())
          this.canvas.addEventListener('mouseout', () => this.stopDrawing())

          // Color picker
          document.getElementById('color-picker').addEventListener('change', e => {
            this.updateBrushPreview()
          })

          // Drag and drop
          const canvasContainer = document.querySelector('.canvas-container')
          canvasContainer.addEventListener('dragover', e => {
            e.preventDefault()
          })

          canvasContainer.addEventListener('drop', e => {
            e.preventDefault()
            const files = e.dataTransfer.files
            if (files.length > 0 && files[0].type.startsWith('image/')) {
              this.loadImage(files[0])
            }
          })

          // Zoom controls
          document.getElementById('zoom-in').addEventListener('click', () => this.zoom(1.2))
          document.getElementById('zoom-out').addEventListener('click', () => this.zoom(0.8))
          document.getElementById('zoom-fit').addEventListener('click', () => this.fitToCanvas())
        }

        loadImage(file) {
          if (!file || !file.type.startsWith('image/')) return

          const reader = new FileReader()
          reader.onload = e => {
            const img = new Image()
            img.onload = () => {
              this.canvas.width = img.width
              this.canvas.height = img.height
              this.ctx.drawImage(img, 0, 0)

              this.originalImageData = this.ctx.getImageData(
                0,
                0,
                this.canvas.width,
                this.canvas.height
              )
              this.currentImageData = this.ctx.getImageData(
                0,
                0,
                this.canvas.width,
                this.canvas.height
              )

              this.saveToHistory()
              this.hideUploadOverlay()
              this.updateUI()
              this.updateImageInfo(file.name, img.width, img.height)
              this.fitToCanvas()
            }
            img.src = e.target.result
          }
          reader.readAsDataURL(file)
        }

        selectTool(tool) {
          this.currentTool = tool

          // Update tool buttons
          document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.classList.remove('active')
          })
          document.querySelector(`[data-tool="${tool}"]`).classList.add('active')

          // Show/hide tool-specific controls
          if (tool === 'text') {
            document.getElementById('text-controls').classList.add('active')
          } else {
            document.getElementById('text-controls').classList.remove('active')
          }

          // Show/hide crop buttons
          if (tool === 'crop') {
            document.getElementById('crop-apply-btn').style.display = 'inline-block'
            document.getElementById('crop-cancel-btn').style.display = 'inline-block'
          } else {
            document.getElementById('crop-apply-btn').style.display = 'none'
            document.getElementById('crop-cancel-btn').style.display = 'none'
            this.cancelCrop()
          }

          // Update cursor
          this.updateCursor()
        }

        updateCursor() {
          const cursors = {
            select: 'default',
            crop: 'crosshair',
            brush: 'crosshair',
            text: 'text',
            rectangle: 'crosshair',
            circle: 'crosshair',
            eraser: 'crosshair'
          }

          this.canvas.style.cursor = cursors[this.currentTool] || 'default'
        }

        startDrawing(e) {
          if (!this.currentImageData) return

          const rect = this.canvas.getBoundingClientRect()
          const x = (e.clientX - rect.left) / this.zoomLevel
          const y = (e.clientY - rect.top) / this.zoomLevel

          this.isDrawing = true
          this.lastX = x
          this.lastY = y

          if (this.currentTool === 'crop') {
            this.cropStart = { x, y }
            this.isCropping = true
          } else if (this.currentTool === 'text') {
            this.addText(x, y)
          }
        }

        draw(e) {
          if (!this.isDrawing || !this.currentImageData) return

          const rect = this.canvas.getBoundingClientRect()
          const x = (e.clientX - rect.left) / this.zoomLevel
          const y = (e.clientY - rect.top) / this.zoomLevel

          if (this.currentTool === 'brush') {
            this.drawBrush(x, y)
          } else if (this.currentTool === 'eraser') {
            this.erase(x, y)
          } else if (this.currentTool === 'crop' && this.isCropping) {
            this.updateCropSelection(x, y)
          } else if (this.currentTool === 'rectangle') {
            this.drawRectangle(x, y)
          } else if (this.currentTool === 'circle') {
            this.drawCircle(x, y)
          }

          this.lastX = x
          this.lastY = y
        }

        stopDrawing() {
          if (this.isDrawing && this.currentTool !== 'crop') {
            this.saveToHistory()
          }
          this.isDrawing = false
        }

        drawBrush(x, y) {
          const brushSize = document.getElementById('brush-size').value
          const color = document.getElementById('color-picker').value

          this.ctx.globalCompositeOperation = 'source-over'
          this.ctx.strokeStyle = color
          this.ctx.lineWidth = brushSize
          this.ctx.lineCap = 'round'
          this.ctx.lineJoin = 'round'

          this.ctx.beginPath()
          this.ctx.moveTo(this.lastX, this.lastY)
          this.ctx.lineTo(x, y)
          this.ctx.stroke()
        }

        erase(x, y) {
          const brushSize = document.getElementById('brush-size').value

          this.ctx.globalCompositeOperation = 'destination-out'
          this.ctx.lineWidth = brushSize
          this.ctx.lineCap = 'round'
          this.ctx.lineJoin = 'round'

          this.ctx.beginPath()
          this.ctx.moveTo(this.lastX, this.lastY)
          this.ctx.lineTo(x, y)
          this.ctx.stroke()

          this.ctx.globalCompositeOperation = 'source-over'
        }

        drawRectangle(x, y) {
          this.restoreCurrentImage()

          const color = document.getElementById('color-picker').value
          const brushSize = document.getElementById('brush-size').value

          this.ctx.strokeStyle = color
          this.ctx.lineWidth = brushSize

          const width = x - this.lastX
          const height = y - this.lastY

          this.ctx.strokeRect(this.lastX, this.lastY, width, height)
        }

        drawCircle(x, y) {
          this.restoreCurrentImage()

          const color = document.getElementById('color-picker').value
          const brushSize = document.getElementById('brush-size').value

          this.ctx.strokeStyle = color
          this.ctx.lineWidth = brushSize

          const radius = Math.sqrt(Math.pow(x - this.lastX, 2) + Math.pow(y - this.lastY, 2))

          this.ctx.beginPath()
          this.ctx.arc(this.lastX, this.lastY, radius, 0, 2 * Math.PI)
          this.ctx.stroke()
        }

        addText(x, y) {
          const text = document.getElementById('text-input').value
          const fontSize = document.getElementById('font-size').value
          const color = document.getElementById('color-picker').value

          if (!text) return

          this.ctx.font = `${fontSize}px Arial`
          this.ctx.fillStyle = color
          this.ctx.fillText(text, x, y)

          this.saveToHistory()
        }

        updateCropSelection(x, y) {
          this.cropEnd = { x, y }
          this.redrawWithCropOverlay()
        }

        redrawWithCropOverlay() {
          this.restoreCurrentImage()

          if (this.cropStart && this.cropEnd) {
            const x = Math.min(this.cropStart.x, this.cropEnd.x)
            const y = Math.min(this.cropStart.y, this.cropEnd.y)
            const width = Math.abs(this.cropEnd.x - this.cropStart.x)
            const height = Math.abs(this.cropEnd.y - this.cropStart.y)

            // Draw overlay
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)

            // Clear crop area
            this.ctx.clearRect(x, y, width, height)

            // Redraw image in crop area
            const imageData = this.currentImageData
            this.ctx.putImageData(imageData, 0, 0, x, y, width, height)

            // Draw crop border
            this.ctx.strokeStyle = '#667eea'
            this.ctx.lineWidth = 2
            this.ctx.strokeRect(x, y, width, height)
          }
        }

        applyCrop() {
          if (!this.cropStart || !this.cropEnd) return

          const x = Math.min(this.cropStart.x, this.cropEnd.x)
          const y = Math.min(this.cropStart.y, this.cropEnd.y)
          const width = Math.abs(this.cropEnd.x - this.cropStart.x)
          const height = Math.abs(this.cropEnd.y - this.cropStart.y)

          if (width > 0 && height > 0) {
            const croppedImageData = this.ctx.getImageData(x, y, width, height)

            this.canvas.width = width
            this.canvas.height = height
            this.ctx.putImageData(croppedImageData, 0, 0)

            this.currentImageData = this.ctx.getImageData(0, 0, width, height)
            this.saveToHistory()
          }

          this.cancelCrop()
        }

        cancelCrop() {
          this.cropStart = null
          this.cropEnd = null
          this.isCropping = false
          this.restoreCurrentImage()
        }

        applyAdjustments() {
          if (!this.originalImageData) return

          const brightness = parseInt(document.getElementById('brightness').value)
          const contrast = parseInt(document.getElementById('contrast').value)
          const saturation = parseInt(document.getElementById('saturation').value)
          const hue = parseInt(document.getElementById('hue').value)

          const imageData = new ImageData(
            new Uint8ClampedArray(this.originalImageData.data),
            this.originalImageData.width,
            this.originalImageData.height
          )

          this.adjustBrightness(imageData, brightness)
          this.adjustContrast(imageData, contrast)
          this.adjustSaturation(imageData, saturation)
          this.adjustHue(imageData, hue)

          this.ctx.putImageData(imageData, 0, 0)
          this.currentImageData = imageData
        }

        adjustBrightness(imageData, value) {
          const data = imageData.data
          for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.max(0, Math.min(255, data[i] + value)) // R
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + value)) // G
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + value)) // B
          }
        }

        adjustContrast(imageData, value) {
          const factor = (259 * (value + 255)) / (255 * (259 - value))
          const data = imageData.data

          for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.max(0, Math.min(255, factor * (data[i] - 128) + 128)) // R
            data[i + 1] = Math.max(0, Math.min(255, factor * (data[i + 1] - 128) + 128)) // G
            data[i + 2] = Math.max(0, Math.min(255, factor * (data[i + 2] - 128) + 128)) // B
          }
        }

        adjustSaturation(imageData, value) {
          const factor = value / 100
          const data = imageData.data

          for (let i = 0; i < data.length; i += 4) {
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]
            data[i] = Math.max(0, Math.min(255, gray + factor * (data[i] - gray))) // R
            data[i + 1] = Math.max(0, Math.min(255, gray + factor * (data[i + 1] - gray))) // G
            data[i + 2] = Math.max(0, Math.min(255, gray + factor * (data[i + 2] - gray))) // B
          }
        }

        adjustHue(imageData, value) {
          const angle = (value * Math.PI) / 180
          const cos = Math.cos(angle)
          const sin = Math.sin(angle)
          const data = imageData.data

          for (let i = 0; i < data.length; i += 4) {
            const r = data[i]
            const g = data[i + 1]
            const b = data[i + 2]

            data[i] = Math.max(
              0,
              Math.min(
                255,
                (0.299 + 0.701 * cos + 0.168 * sin) * r +
                  (0.587 - 0.587 * cos + 0.33 * sin) * g +
                  (0.114 - 0.114 * cos - 0.497 * sin) * b
              )
            )

            data[i + 1] = Math.max(
              0,
              Math.min(
                255,
                (0.299 - 0.299 * cos - 0.328 * sin) * r +
                  (0.587 + 0.413 * cos + 0.035 * sin) * g +
                  (0.114 - 0.114 * cos + 0.292 * sin) * b
              )
            )

            data[i + 2] = Math.max(
              0,
              Math.min(
                255,
                (0.299 - 0.3 * cos + 1.25 * sin) * r +
                  (0.587 - 0.588 * cos - 1.05 * sin) * g +
                  (0.114 + 0.886 * cos - 0.203 * sin) * b
              )
            )
          }
        }

        applyFilter(filter) {
          if (!this.currentImageData) return

          // Update filter buttons
          document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.remove('active')
          })
          document.querySelector(`[data-filter="${filter}"]`).classList.add('active')

          // Reset to current image
          this.restoreCurrentImage()

          // Apply filter
          switch (filter) {
            case 'grayscale':
              this.applyGrayscale()
              break
            case 'sepia':
              this.applySepia()
              break
            case 'blur':
              this.applyBlur()
              break
            case 'sharpen':
              this.applySharpen()
              break
            case 'vintage':
              this.applyVintage()
              break
            default:
              // No filter
              break
          }
        }

        applyGrayscale() {
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
          const data = imageData.data

          for (let i = 0; i < data.length; i += 4) {
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]
            data[i] = gray // R
            data[i + 1] = gray // G
            data[i + 2] = gray // B
          }

          this.ctx.putImageData(imageData, 0, 0)
        }

        applySepia() {
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
          const data = imageData.data

          for (let i = 0; i < data.length; i += 4) {
            const r = data[i]
            const g = data[i + 1]
            const b = data[i + 2]

            data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189) // R
            data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168) // G
            data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131) // B
          }

          this.ctx.putImageData(imageData, 0, 0)
        }

        applyBlur() {
          // Simple box blur
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
          const data = imageData.data
          const width = imageData.width
          const height = imageData.height
          const newData = new Uint8ClampedArray(data)

          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              for (let c = 0; c < 3; c++) {
                let sum = 0
                for (let dy = -1; dy <= 1; dy++) {
                  for (let dx = -1; dx <= 1; dx++) {
                    const idx = ((y + dy) * width + (x + dx)) * 4 + c
                    sum += data[idx]
                  }
                }
                const idx = (y * width + x) * 4 + c
                newData[idx] = sum / 9
              }
            }
          }

          const blurredImageData = new ImageData(newData, width, height)
          this.ctx.putImageData(blurredImageData, 0, 0)
        }

        applySharpen() {
          // Sharpening kernel
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
          const data = imageData.data
          const width = imageData.width
          const height = imageData.height
          const newData = new Uint8ClampedArray(data)

          const kernel = [
            [0, -1, 0],
            [-1, 5, -1],
            [0, -1, 0]
          ]

          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              for (let c = 0; c < 3; c++) {
                let sum = 0
                for (let dy = -1; dy <= 1; dy++) {
                  for (let dx = -1; dx <= 1; dx++) {
                    const idx = ((y + dy) * width + (x + dx)) * 4 + c
                    sum += data[idx] * kernel[dy + 1][dx + 1]
                  }
                }
                const idx = (y * width + x) * 4 + c
                newData[idx] = Math.max(0, Math.min(255, sum))
              }
            }
          }

          const sharpenedImageData = new ImageData(newData, width, height)
          this.ctx.putImageData(sharpenedImageData, 0, 0)
        }

        applyVintage() {
          this.applySepia()

          // Add noise and vignette effect
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height)
          const data = imageData.data
          const width = imageData.width
          const height = imageData.height
          const centerX = width / 2
          const centerY = height / 2
          const maxDist = Math.sqrt(centerX * centerX + centerY * centerY)

          for (let i = 0; i < data.length; i += 4) {
            const x = (i / 4) % width
            const y = Math.floor(i / 4 / width)
            const dist = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY))
            const vignette = 1 - (dist / maxDist) * 0.5

            // Add noise
            const noise = (Math.random() - 0.5) * 20

            data[i] = Math.max(0, Math.min(255, data[i] * vignette + noise)) // R
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] * vignette + noise)) // G
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] * vignette + noise)) // B
          }

          this.ctx.putImageData(imageData, 0, 0)
        }

        saveToHistory() {
          if (!this.currentImageData) return

          // Remove any history after current index
          this.history = this.history.slice(0, this.historyIndex + 1)

          // Add current state
          this.history.push(
            new ImageData(
              new Uint8ClampedArray(this.currentImageData.data),
              this.currentImageData.width,
              this.currentImageData.height
            )
          )

          this.historyIndex++

          // Limit history size
          if (this.history.length > 20) {
            this.history.shift()
            this.historyIndex--
          }

          this.updateUI()
        }

        undo() {
          if (this.historyIndex > 0) {
            this.historyIndex--
            const imageData = this.history[this.historyIndex]

            this.canvas.width = imageData.width
            this.canvas.height = imageData.height
            this.ctx.putImageData(imageData, 0, 0)
            this.currentImageData = new ImageData(
              new Uint8ClampedArray(imageData.data),
              imageData.width,
              imageData.height
            )

            this.updateUI()
          }
        }

        redo() {
          if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++
            const imageData = this.history[this.historyIndex]

            this.canvas.width = imageData.width
            this.canvas.height = imageData.height
            this.ctx.putImageData(imageData, 0, 0)
            this.currentImageData = new ImageData(
              new Uint8ClampedArray(imageData.data),
              imageData.width,
              imageData.height
            )

            this.updateUI()
          }
        }

        reset() {
          if (this.originalImageData) {
            this.canvas.width = this.originalImageData.width
            this.canvas.height = this.originalImageData.height
            this.ctx.putImageData(this.originalImageData, 0, 0)
            this.currentImageData = new ImageData(
              new Uint8ClampedArray(this.originalImageData.data),
              this.originalImageData.width,
              this.originalImageData.height
            )

            // Reset sliders
            document.getElementById('brightness').value = 0
            document.getElementById('contrast').value = 0
            document.getElementById('saturation').value = 0
            document.getElementById('hue').value = 0

            // Update slider values
            document.getElementById('brightness-value').textContent = '0'
            document.getElementById('contrast-value').textContent = '0'
            document.getElementById('saturation-value').textContent = '0'
            document.getElementById('hue-value').textContent = '0'

            // Reset filter
            document.querySelectorAll('.filter-btn').forEach(btn => {
              btn.classList.remove('active')
            })
            document.querySelector('[data-filter="none"]').classList.add('active')

            this.saveToHistory()
          }
        }

        restoreCurrentImage() {
          if (this.currentImageData) {
            this.ctx.putImageData(this.currentImageData, 0, 0)
          }
        }

        saveImage() {
          if (!this.currentImageData) return

          const link = document.createElement('a')
          link.download = 'edited-image.png'
          link.href = this.canvas.toDataURL()
          link.click()
        }

        updateBrushPreview() {
          const size = document.getElementById('brush-size').value
          const color = document.getElementById('color-picker').value
          const preview = document.getElementById('brush-preview')

          preview.style.width = Math.min(40, size) + 'px'
          preview.style.height = Math.min(40, size) + 'px'
          preview.style.backgroundColor = color
        }

        zoom(factor) {
          this.zoomLevel *= factor
          this.zoomLevel = Math.max(0.1, Math.min(5, this.zoomLevel))

          const wrapper = document.querySelector('.canvas-wrapper')
          wrapper.style.transform = `scale(${this.zoomLevel})`

          document.getElementById('zoom-level').textContent = Math.round(this.zoomLevel * 100) + '%'
        }

        fitToCanvas() {
          if (!this.currentImageData) return

          const container = document.querySelector('.canvas-container')
          const containerWidth = container.clientWidth - 40
          const containerHeight = container.clientHeight - 40

          const scaleX = containerWidth / this.canvas.width
          const scaleY = containerHeight / this.canvas.height

          this.zoomLevel = Math.min(scaleX, scaleY, 1)

          const wrapper = document.querySelector('.canvas-wrapper')
          wrapper.style.transform = `scale(${this.zoomLevel})`

          document.getElementById('zoom-level').textContent = Math.round(this.zoomLevel * 100) + '%'
        }

        updateUI() {
          const hasImage = this.currentImageData !== null
          const canUndo = this.historyIndex > 0
          const canRedo = this.historyIndex < this.history.length - 1

          document.getElementById('save-btn').disabled = !hasImage
          document.getElementById('undo-btn').disabled = !canUndo
          document.getElementById('redo-btn').disabled = !canRedo
          document.getElementById('reset-btn').disabled = !hasImage
        }

        updateImageInfo(filename, width, height) {
          document.getElementById('image-info').textContent = `${filename} - ${width} Ã— ${height}px`
        }

        hideUploadOverlay() {
          document.getElementById('upload-overlay').style.display = 'none'
        }
      }

      // Initialize the editor when the page loads
      window.addEventListener('DOMContentLoaded', () => {
        new ImageEditor()
      })
    </script>
  </body>
</html>
