<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å›¾ç‰‡ç”Ÿæˆå™¨ - Vue ç‰ˆæœ¬</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
        }

        #app {
            min-height: 100vh;
        }

        .image-generator {
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            margin: 0;
            opacity: 0.9;
        }

        .generator-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .config-section {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .config-section h3 {
            margin: 0 0 15px 0;
            color: #374151;
            font-size: 16px;
            font-weight: 600;
        }

        .api-config {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .api-config h3 {
            margin: 0 0 15px 0;
            color: #856404;
            font-size: 16px;
            font-weight: 600;
        }

        .config-item {
            margin-bottom: 15px;
        }

        .config-item:last-child {
            margin-bottom: 0;
        }

        .config-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .api-config .config-item label {
            color: #856404;
        }

        .form-select,
        .form-input,
        .prompt-textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .api-config .form-select,
        .api-config .form-input {
            border-color: #ffeaa7;
        }

        .form-select:focus,
        .form-input:focus,
        .prompt-textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .api-config .form-select:focus,
        .api-config .form-input:focus {
            border-color: #f39c12;
            box-shadow: 0 0 0 2px rgba(243, 156, 18, 0.2);
        }

        .prompt-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
            line-height: 1.5;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .mode-selection {
            margin-bottom: 20px;
        }

        .mode-option {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        .mode-option input[type="radio"] {
            margin-right: 8px;
        }

        .mode-option span {
            color: #374151;
        }

        .generate-section {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 140px;
            justify-content: center;
        }

        .generate-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .clear-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }

        .clear-btn:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .result-display {
            margin-top: 20px;
        }

        .loading-state,
        .error-state {
            text-align: center;
            padding: 40px 20px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .error-state {
            background: #fef2f2;
            border-color: #fecaca;
        }

        .error-message {
            color: #dc2626;
            margin: 0;
            font-weight: 500;
        }

        .results {
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            padding: 20px;
        }

        .results h3 {
            margin: 0 0 20px 0;
            color: #374151;
            font-size: 18px;
            font-weight: 600;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .image-item {
            position: relative;
            background: #f9fafb;
            border-radius: 8px;
            overflow: hidden;
            transition: transform 0.2s;
        }

        .image-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .generated-image {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 8px;
        }

        .help-text {
            color: #856404;
            margin-top: 5px;
            display: block;
            font-size: 12px;
        }

        .help-link {
            color: #856404;
            text-decoration: underline;
        }

        .help-link:hover {
            color: #6c5ce7;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .generator-content {
                padding: 20px;
                margin: 0 10px;
            }
            
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            .generate-section {
                flex-direction: column;
                align-items: center;
            }
            
            .generate-btn,
            .clear-btn {
                width: 100%;
                max-width: 300px;
            }
            
            .image-grid {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 15px;
            }
            
            .container {
                padding: 0 10px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <image-generator-main></image-generator-main>
    </div>

    <script type="module">
        const { createApp, ref, computed, onMounted, watch } = Vue;

        // Provider Manager (simplified for inline use)
        class SimpleProviderManager {
            constructor() {
                this.currentProvider = 'gemini';
                this.providers = {
                    gemini: { name: 'gemini', displayName: 'Google Gemini' },
                    siliconflow: { name: 'siliconflow', displayName: 'SiliconFlow' },
                    cloudflare: { name: 'cloudflare', displayName: 'Cloudflare Workers AI' },
                    chutesai: { name: 'chutesai', displayName: 'Chutes AI' }
                };
                this.loadSelectedProvider();
            }

            getProviderNames() {
                return Object.keys(this.providers);
            }

            getCurrentProviderName() {
                return this.currentProvider;
            }

            setCurrentProvider(name) {
                this.currentProvider = name;
                localStorage.setItem('selected_provider', name);
            }

            getCurrentProvider() {
                return this.providers[this.currentProvider];
            }

            loadSelectedProvider() {
                const saved = localStorage.getItem('selected_provider');
                if (saved && this.providers[saved]) {
                    this.currentProvider = saved;
                }
            }

            supportsImageEditing() {
                return this.currentProvider === 'gemini';
            }

            supportsModels() {
                return this.currentProvider === 'cloudflare' || this.currentProvider === 'chutesai';
            }

            async generateImages(request) {
                // Simulate API call
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        reject(new Error('è¯·åœ¨å®é™…é¡¹ç›®ä¸­å®ç° API è°ƒç”¨åŠŸèƒ½'));
                    }, 2000);
                });
            }

            async downloadImage(url, filename) {
                // Simulate download
                console.log('Downloading:', filename);
            }

            async copyToClipboard(url) {
                try {
                    await navigator.clipboard.writeText(url);
                } catch (err) {
                    console.error('Copy failed:', err);
                }
            }
        }

        // Provider configs
        const PROVIDER_CONFIGS = {
            gemini: {
                name: 'gemini',
                displayName: 'Google Gemini',
                placeholder: 'è¯·è¾“å…¥æ‚¨çš„ Gemini API Key',
                helpText: 'è·å– API Key',
                helpLink: 'https://ai.google.dev/gemini-api/docs/api-key',
                supportsImageEditing: true
            },
            siliconflow: {
                name: 'siliconflow',
                displayName: 'SiliconFlow',
                placeholder: 'è¯·è¾“å…¥æ‚¨çš„ SiliconFlow API Key',
                helpText: 'è·å– API Key',
                helpLink: 'https://cloud.siliconflow.cn'
            },
            cloudflare: {
                name: 'cloudflare',
                displayName: 'Cloudflare Workers AI',
                placeholder: 'è¯·è¾“å…¥ Account ID:API Token (ä¾‹å¦‚: abc123:def456)',
                helpText: 'è·å–å‡­æ®',
                helpLink: 'https://dash.cloudflare.com/profile/api-tokens',
                supportsModels: true,
                models: [
                    { id: '@cf/black-forest-labs/flux-1-schnell', name: 'Flux 1 Schnell (å¿«é€Ÿ)' },
                    { id: '@cf/bytedance/stable-diffusion-xl-lightning', name: 'Stable Diffusion XL Lightning' }
                ]
            },
            chutesai: {
                name: 'chutesai',
                displayName: 'Chutes AI',
                placeholder: 'è¯·è¾“å…¥æ‚¨çš„ Chutes AI API Token',
                helpText: 'è·å– API Token',
                helpLink: 'https://chutes.ai',
                supportsModels: true,
                models: [
                    { id: 'neta-lumina', name: 'Neta Lumina' },
                    { id: 'chroma', name: 'Chroma' },
                    { id: 'JuggernautXL', name: 'JuggernautXL' }
                ]
            }
        };

        const ASPECT_RATIOS = [
            { value: '1:1', label: 'æ­£æ–¹å½¢ (1:1)' },
            { value: '16:9', label: 'å®½å± (16:9)' },
            { value: '9:16', label: 'ç«–å± (9:16)' },
            { value: '4:3', label: 'æ ‡å‡† (4:3)' },
            { value: '3:4', label: 'è‚–åƒ (3:4)' }
        ];

        const ART_STYLES = [
            { value: '', label: 'é»˜è®¤' },
            { value: 'realistic', label: 'å†™å®é£æ ¼' },
            { value: 'anime', label: 'åŠ¨æ¼«é£æ ¼' },
            { value: 'cartoon', label: 'å¡é€šé£æ ¼' },
            { value: 'oil-painting', label: 'æ²¹ç”»é£æ ¼' },
            { value: 'watercolor', label: 'æ°´å½©é£æ ¼' },
            { value: 'sketch', label: 'ç´ æé£æ ¼' },
            { value: 'digital-art', label: 'æ•°å­—è‰ºæœ¯' },
            { value: 'pixel-art', label: 'åƒç´ è‰ºæœ¯' }
        ];

        const IMAGE_COUNTS = [
            { value: 1, label: '1 å¼ ' },
            { value: 2, label: '2 å¼ ' },
            { value: 4, label: '4 å¼ ' }
        ];

        // API Config Component
        const ApiConfig = {
            props: ['providerManager'],
            emits: ['provider-changed', 'api-key-changed', 'model-changed'],
            setup(props, { emit }) {
                const selectedProvider = ref(props.providerManager.getCurrentProviderName());
                const apiKey = ref('');
                const selectedModel = ref('');

                const providerNames = computed(() => props.providerManager.getProviderNames());
                const currentProviderConfig = computed(() => PROVIDER_CONFIGS[selectedProvider.value]);

                const getProviderDisplayName = (providerName) => {
                    return PROVIDER_CONFIGS[providerName]?.displayName || providerName;
                };

                const onProviderChange = () => {
                    props.providerManager.setCurrentProvider(selectedProvider.value);
                    loadApiKey();
                    loadModel();
                    emit('provider-changed', selectedProvider.value);
                };

                const onApiKeyChange = () => {
                    // In real implementation, save to provider
                    localStorage.setItem(`${selectedProvider.value}_api_key`, apiKey.value);
                    emit('api-key-changed', apiKey.value);
                };

                const onModelChange = () => {
                    localStorage.setItem(`${selectedProvider.value}_selected_model`, selectedModel.value);
                    emit('model-changed', selectedModel.value);
                };

                const loadApiKey = () => {
                    const saved = localStorage.getItem(`${selectedProvider.value}_api_key`);
                    apiKey.value = saved || '';
                };

                const loadModel = () => {
                    if (currentProviderConfig.value?.supportsModels) {
                        const saved = localStorage.getItem(`${selectedProvider.value}_selected_model`);
                        selectedModel.value = saved || currentProviderConfig.value.models?.[0]?.id || '';
                    }
                };

                onMounted(() => {
                    loadApiKey();
                    loadModel();
                });

                watch(() => selectedProvider.value, () => {
                    loadApiKey();
                    loadModel();
                });

                return {
                    selectedProvider,
                    apiKey,
                    selectedModel,
                    providerNames,
                    currentProviderConfig,
                    getProviderDisplayName,
                    onProviderChange,
                    onApiKeyChange,
                    onModelChange
                };
            },
            template: `
                <div class="api-config">
                    <h3>âš™ï¸ API é…ç½®</h3>

                    <div class="config-item">
                        <label for="providerSelect">é€‰æ‹©æœåŠ¡å•†</label>
                        <select
                            id="providerSelect"
                            v-model="selectedProvider"
                            @change="onProviderChange"
                            class="form-select"
                        >
                            <option
                                v-for="provider in providerNames"
                                :key="provider"
                                :value="provider"
                            >
                                {{ getProviderDisplayName(provider) }}
                            </option>
                        </select>
                    </div>

                    <div class="config-item">
                        <input
                            type="password"
                            v-model="apiKey"
                            @input="onApiKeyChange"
                            :placeholder="currentProviderConfig?.placeholder || 'è¯·è¾“å…¥æ‚¨çš„ API Key'"
                            class="form-input"
                        >
                        <small class="help-text">
                            {{ currentProviderConfig?.helpText }}:
                            <a
                                :href="currentProviderConfig?.helpLink"
                                target="_blank"
                                class="help-link"
                            >
                                {{ getProviderDisplayName(selectedProvider) }}
                            </a>
                        </small>
                    </div>

                    <div
                        v-if="currentProviderConfig?.supportsModels"
                        class="config-item"
                    >
                        <label for="modelSelect">é€‰æ‹©æ¨¡å‹</label>
                        <select
                            id="modelSelect"
                            v-model="selectedModel"
                            @change="onModelChange"
                            class="form-select"
                        >
                            <option
                                v-for="model in currentProviderConfig.models"
                                :key="model.id"
                                :value="model.id"
                            >
                                {{ model.name }}
                            </option>
                        </select>
                    </div>
                </div>
            `
        };

        // Generation Mode Component
        const GenerationMode = {
            props: ['providerManager', 'modelValue'],
            emits: ['update:modelValue', 'mode-changed'],
            setup(props, { emit }) {
                const selectedMode = ref(props.modelValue || 'generate');

                const supportsImageEditing = computed(() => {
                    return props.providerManager.supportsImageEditing();
                });

                const onModeChange = () => {
                    if (selectedMode.value === 'edit' && !supportsImageEditing.value) {
                        selectedMode.value = 'generate';
                        return;
                    }

                    emit('update:modelValue', selectedMode.value);
                    emit('mode-changed', selectedMode.value);
                };

                watch(() => props.modelValue, (newMode) => {
                    selectedMode.value = newMode;
                });

                watch(supportsImageEditing, (supports) => {
                    if (!supports && selectedMode.value === 'edit') {
                        selectedMode.value = 'generate';
                        onModeChange();
                    }
                });

                return {
                    selectedMode,
                    supportsImageEditing,
                    onModeChange
                };
            },
            template: `
                <div class="config-section">
                    <h3>ğŸ¯ ç”Ÿæˆæ¨¡å¼</h3>

                    <div class="mode-selection">
                        <label class="mode-option">
                            <input
                                type="radio"
                                name="mode"
                                value="generate"
                                v-model="selectedMode"
                                @change="onModeChange"
                            >
                            <span>ğŸ¨ æ–‡æœ¬ç”Ÿæˆå›¾ç‰‡</span>
                        </label>

                        <label class="mode-option">
                            <input
                                type="radio"
                                name="mode"
                                value="edit"
                                v-model="selectedMode"
                                @change="onModeChange"
                                :disabled="!supportsImageEditing"
                            >
                            <span>âœï¸ å›¾ç‰‡ç¼–è¾‘</span>
                            <small v-if="!supportsImageEditing" style="color: #6b7280; font-size: 12px; margin-left: 8px;">
                                (ä»…æ”¯æŒ Google Gemini)
                            </small>
                        </label>
                    </div>
                </div>
            `
        };

        // Prompt Input Component
        const PromptInput = {
            props: ['modelValue', 'isEditMode'],
            emits: ['update:modelValue', 'prompt-changed'],
            setup(props, { emit }) {
                const promptText = ref(props.modelValue || '');

                const placeholder = computed(() => {
                    if (props.isEditMode) {
                        return 'ä¾‹å¦‚ï¼šåœ¨å›¾ç‰‡ä¸­æ·»åŠ ä¸€åªå°ç‹—ï¼Œè®©èƒŒæ™¯å˜æˆå¤•é˜³...';
                    }
                    return 'ä¾‹å¦‚ï¼šä¸€åªå¯çˆ±çš„æ©˜çŒ«ååœ¨æ¨±èŠ±æ ‘ä¸‹ï¼Œé˜³å…‰é€è¿‡èŠ±ç“£æ´’åœ¨åœ°é¢ä¸Šï¼Œæ¸©æš–çš„æ˜¥æ—¥æ°›å›´...';
                });

                const onPromptChange = () => {
                    emit('update:modelValue', promptText.value);
                    emit('prompt-changed', promptText.value);
                };

                watch(() => props.modelValue, (newValue) => {
                    promptText.value = newValue;
                });

                return {
                    promptText,
                    placeholder,
                    onPromptChange
                };
            },
            template: `
                <div class="config-section">
                    <label for="prompt">
                        {{ isEditMode ? 'âœï¸ æè¿°æ‚¨æƒ³è¦å¯¹å›¾ç‰‡è¿›è¡Œçš„ä¿®æ”¹' : 'ğŸ“ æè¿°æ‚¨æƒ³è¦ç”Ÿæˆçš„å›¾ç‰‡' }}
                    </label>

                    <div class="input-group">
                        <textarea
                            id="prompt"
                            v-model="promptText"
                            @input="onPromptChange"
                            :placeholder="placeholder"
                            class="prompt-textarea"
                            rows="4"
                            required
                        ></textarea>
                    </div>
                </div>
            `
        };

        // Generation Config Component
        const GenerationConfig = {
            props: ['modelValue'],
            emits: ['update:modelValue', 'config-changed'],
            setup(props, { emit }) {
                const imageCount = ref(props.modelValue?.imageCount || 4);
                const aspectRatio = ref(props.modelValue?.aspectRatio || '1:1');
                const style = ref(props.modelValue?.style || '');

                const emitChange = () => {
                    const config = {
                        imageCount: imageCount.value,
                        aspectRatio: aspectRatio.value,
                        style: style.value
                    };

                    emit('update:modelValue', config);
                    emit('config-changed', config);
                };

                const onImageCountChange = () => emitChange();
                const onAspectRatioChange = () => emitChange();
                const onStyleChange = () => emitChange();

                watch(() => props.modelValue, (newValue) => {
                    if (newValue) {
                        imageCount.value = newValue.imageCount;
                        aspectRatio.value = newValue.aspectRatio;
                        style.value = newValue.style;
                    }
                }, { deep: true });

                return {
                    imageCount,
                    aspectRatio,
                    style,
                    onImageCountChange,
                    onAspectRatioChange,
                    onStyleChange,
                    IMAGE_COUNTS,
                    ASPECT_RATIOS,
                    ART_STYLES
                };
            },
            template: `
                <div class="config-section">
                    <div class="config-grid">
                        <div class="config-item">
                            <label for="imageCount">ç”Ÿæˆæ•°é‡</label>
                            <select
                                id="imageCount"
                                v-model="imageCount"
                                @change="onImageCountChange"
                                class="form-select"
                            >
                                <option
                                    v-for="count in IMAGE_COUNTS"
                                    :key="count.value"
                                    :value="count.value"
                                >
                                    {{ count.label }}
                                </option>
                            </select>
                        </div>

                        <div class="config-item">
                            <label for="aspectRatio">å®½é«˜æ¯”</label>
                            <select
                                id="aspectRatio"
                                v-model="aspectRatio"
                                @change="onAspectRatioChange"
                                class="form-select"
                            >
                                <option
                                    v-for="ratio in ASPECT_RATIOS"
                                    :key="ratio.value"
                                    :value="ratio.value"
                                >
                                    {{ ratio.label }}
                                </option>
                            </select>
                        </div>

                        <div class="config-item">
                            <label for="style">è‰ºæœ¯é£æ ¼</label>
                            <select
                                id="style"
                                v-model="style"
                                @change="onStyleChange"
                                class="form-select"
                            >
                                <option
                                    v-for="styleOption in ART_STYLES"
                                    :key="styleOption.value"
                                    :value="styleOption.value"
                                >
                                    {{ styleOption.label }}
                                </option>
                            </select>
                        </div>
                    </div>
                </div>
            `
        };

        // Result Display Component
        const ResultDisplay = {
            props: ['isLoading', 'error', 'images'],
            emits: ['download-image', 'copy-image-url'],
            setup(props, { emit }) {
                const downloadImage = (url, index) => {
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
                    const filename = `generated-image-${timestamp}-${index + 1}.png`;
                    emit('download-image', url, filename);
                };

                const copyImageUrl = (url) => {
                    emit('copy-image-url', url);
                };

                return {
                    downloadImage,
                    copyImageUrl
                };
            },
            template: `
                <div class="result-display">
                    <!-- Loading State -->
                    <div v-if="isLoading" class="loading-state">
                        <div class="loading-spinner" style="width: 40px; height: 40px; border: 4px solid #f3f4f6; border-top: 4px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 16px;"></div>
                        <p>æ­£åœ¨ç”Ÿæˆå›¾ç‰‡ï¼Œè¯·ç¨å€™...</p>
                    </div>

                    <!-- Error State -->
                    <div v-else-if="error" class="error-state">
                        <div style="font-size: 32px; margin-bottom: 12px;">âŒ</div>
                        <p class="error-message">{{ error }}</p>
                    </div>

                    <!-- Results -->
                    <div v-else-if="images.length > 0" class="results">
                        <h3>âœ¨ ç”Ÿæˆç»“æœ</h3>
                        <div class="image-grid">
                            <div
                                v-for="(image, index) in images"
                                :key="index"
                                class="image-item"
                            >
                                <img
                                    :src="image"
                                    :alt="'Generated image ' + (index + 1)"
                                    class="generated-image"
                                >
                                <div style="position: absolute; top: 8px; right: 8px; display: flex; gap: 4px; opacity: 0; transition: opacity 0.2s;" :style="{ opacity: 1 }">
                                    <button
                                        @click="downloadImage(image, index)"
                                        style="background: rgba(0, 0, 0, 0.7); color: white; border: none; width: 32px; height: 32px; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center;"
                                        title="ä¸‹è½½å›¾ç‰‡"
                                    >
                                        ğŸ“¥
                                    </button>
                                    <button
                                        @click="copyImageUrl(image)"
                                        style="background: rgba(0, 0, 0, 0.7); color: white; border: none; width: 32px; height: 32px; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center;"
                                        title="å¤åˆ¶é“¾æ¥"
                                    >
                                        ğŸ“‹
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `
        };

        // Main Image Generator Component
        const ImageGeneratorMain = {
            components: {
                ApiConfig,
                GenerationMode,
                PromptInput,
                GenerationConfig,
                ResultDisplay
            },
            setup() {
                const providerManager = new SimpleProviderManager();
                const isGenerating = ref(false);
                const error = ref(null);
                const generatedImages = ref([]);

                // Form data
                const generationMode = ref('generate');
                const prompt = ref('');
                const generationConfig = ref({
                    imageCount: 4,
                    aspectRatio: '1:1',
                    style: ''
                });

                // Computed
                const canGenerate = computed(() => {
                    const hasPrompt = prompt.value.trim().length > 0;
                    const hasApiKey = localStorage.getItem(`${providerManager.getCurrentProviderName()}_api_key`);
                    return hasPrompt && hasApiKey && !isGenerating.value;
                });

                // Event handlers
                const onProviderChanged = (provider) => {
                    console.log('Provider changed to:', provider);
                    if (generationMode.value === 'edit' && !providerManager.supportsImageEditing()) {
                        generationMode.value = 'generate';
                    }
                };

                const onApiKeyChanged = (key) => {
                    console.log('API key changed');
                };

                const onModelChanged = (model) => {
                    console.log('Model changed to:', model);
                };

                const onModeChanged = (mode) => {
                    console.log('Mode changed to:', mode);
                };

                const onPromptChanged = (newPrompt) => {
                    console.log('Prompt changed');
                };

                const onConfigChanged = (config) => {
                    console.log('Config changed:', config);
                };

                const onGenerate = async () => {
                    if (!canGenerate.value) return;

                    isGenerating.value = true;
                    error.value = null;
                    generatedImages.value = [];

                    try {
                        const request = {
                            prompt: prompt.value.trim(),
                            aspectRatio: generationConfig.value.aspectRatio,
                            numberOfImages: generationConfig.value.imageCount,
                            style: generationConfig.value.style || undefined,
                            editMode: generationMode.value === 'edit'
                        };

                        const images = await providerManager.generateImages(request);
                        generatedImages.value = images;
                    } catch (err) {
                        error.value = err.message || 'ç”Ÿæˆå›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
                        console.error('Generation failed:', err);
                    } finally {
                        isGenerating.value = false;
                    }
                };

                const onClear = () => {
                    generatedImages.value = [];
                    error.value = null;
                };

                const onDownloadImage = async (url, filename) => {
                    try {
                        await providerManager.downloadImage(url, filename);
                    } catch (err) {
                        alert(err.message || 'ä¸‹è½½å¤±è´¥');
                    }
                };

                const onCopyImageUrl = async (url) => {
                    try {
                        await providerManager.copyToClipboard(url);
                        alert('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    } catch (err) {
                        alert('å¤åˆ¶å¤±è´¥');
                    }
                };

                return {
                    providerManager,
                    isGenerating,
                    error,
                    generatedImages,
                    generationMode,
                    prompt,
                    generationConfig,
                    canGenerate,
                    onProviderChanged,
                    onApiKeyChanged,
                    onModelChanged,
                    onModeChanged,
                    onPromptChanged,
                    onConfigChanged,
                    onGenerate,
                    onClear,
                    onDownloadImage,
                    onCopyImageUrl
                };
            },
            template: `
                <div class="image-generator">
                    <div class="container">
                        <header class="header">
                            <h1>ğŸ¨ AI å›¾ç‰‡ç”Ÿæˆå™¨</h1>
                            <p>ä½¿ç”¨å…ˆè¿›çš„ AI æŠ€æœ¯ï¼Œå°†æ‚¨çš„æƒ³è±¡è½¬åŒ–ä¸ºç²¾ç¾çš„å›¾ç‰‡</p>
                        </header>

                        <div class="generator-content">
                            <!-- API Configuration -->
                            <ApiConfig
                                :provider-manager="providerManager"
                                @provider-changed="onProviderChanged"
                                @api-key-changed="onApiKeyChanged"
                                @model-changed="onModelChanged"
                            />

                            <!-- Generation Mode -->
                            <GenerationMode
                                v-model="generationMode"
                                :provider-manager="providerManager"
                                @mode-changed="onModeChanged"
                            />

                            <!-- Prompt Input -->
                            <PromptInput
                                v-model="prompt"
                                :is-edit-mode="generationMode === 'edit'"
                                @prompt-changed="onPromptChanged"
                            />

                            <!-- Generation Configuration -->
                            <GenerationConfig
                                v-model="generationConfig"
                                @config-changed="onConfigChanged"
                            />

                            <!-- Generate Button -->
                            <div class="generate-section">
                                <button
                                    @click="onGenerate"
                                    :disabled="isGenerating || !canGenerate"
                                    class="generate-btn"
                                >
                                    <span v-if="isGenerating" class="loading-spinner"></span>
                                    {{ isGenerating ? 'ç”Ÿæˆä¸­...' : 'ğŸ¨ ç”Ÿæˆå›¾ç‰‡' }}
                                </button>

                                <button
                                    v-if="generatedImages.length > 0"
                                    @click="onClear"
                                    class="clear-btn"
                                >
                                    ğŸ—‘ï¸ æ¸…ç©ºç»“æœ
                                </button>
                            </div>

                            <!-- Results Display -->
                            <ResultDisplay
                                :is-loading="isGenerating"
                                :error="error"
                                :images="generatedImages"
                                @download-image="onDownloadImage"
                                @copy-image-url="onCopyImageUrl"
                            />
                        </div>
                    </div>
                </div>
            `
        };

        // Create and mount the Vue app
        const app = createApp({
            components: {
                ImageGeneratorMain
            }
        });

        app.mount('#app');
    </script>
</body>
</html>
