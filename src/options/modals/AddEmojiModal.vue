<script setup lang="ts">
import { ref, watch, toRefs, reactive, computed } from 'vue'
import { DownOutlined, DeleteOutlined } from '@ant-design/icons-vue'

import { useEmojiStore } from '../../stores/emojiStore'

const props = defineProps<{ show: boolean; groups: unknown[]; defaultGroupId?: string }>()

// expose props as refs for template and internal use
const { groups, show, defaultGroupId } = toRefs(props as any)

const emits = defineEmits(['update:show', 'added'])

const onVariantSelectForItem = (index: number, info: { key: string | number }) => {
  const item = parsedItems.value[index]
  if (item) setItemSelectedVariant(item, info)
}

const removeParsedItem = (index: number) => {
  parsedItems.value.splice(index, 1)
}

const name = ref('')
const url = ref('')
const displayUrl = ref('')
const inputMode = ref<'url' | 'markdown' | 'html'>('url')
const pasteText = ref('')
const parsedItems = ref<ImageVariant[]>([])
const autoPreview = ref(false)
let previewTimer: number | null = null
// initialize groupId from reactive props
const groupId = ref(
  (defaultGroupId?.value as string) || (groups?.value && groups.value[0]?.id) || ''
)

// Keep groupId in sync when defaultGroupId prop changes
watch(defaultGroupId, v => {
  if (v) groupId.value = v
})

// If groups list changes (e.g. first load), ensure we have a sensible default
watch(
  groups,
  g => {
    const list = g as any[]
    if (
      (!groupId.value || !list?.find((x: any) => x.id === groupId.value)) &&
      list &&
      list.length
    ) {
      groupId.value = (defaultGroupId?.value as string) || list[0].id || ''
    }
  },
  { immediate: true }
)

// Reset fields when the modal opens so repeated opens work without refresh
watch(show, v => {
  if (v) {
    name.value = ''
    url.value = ''
    displayUrl.value = ''
    groupId.value = (defaultGroupId?.value as string) || (groups.value && groups.value[0]?.id) || ''
    pasteText.value = ''
    parsedItems.value = []
    inputMode.value = 'url'
    imageLoadError.value = false // ÈáçÁΩÆÂõæÁâáÈîôËØØÁä∂ÊÄÅ
  }
})

// ÁõëÂê¨ URL ÂèòÂåñÔºåÈáçÁΩÆÂõæÁâáÈîôËØØÁä∂ÊÄÅ
watch(
  () => [url.value, displayUrl.value],
  () => {
    imageLoadError.value = false
  }
)

// Ëá™Âä®È¢ÑËßàÈò≤ÊäñÔºöÂΩì autoPreview ÂºÄÂêØÂπ∂‰∏î pasteText ÂèòÂåñÊó∂ÔºåÂª∂ËøüÊâßË°å previewParse
watch(
  () => pasteText.value,
  () => {
    if (!autoPreview.value) return
    if (previewTimer) window.clearTimeout(previewTimer)
    // use window.setTimeout to get numeric id
    previewTimer = window.setTimeout(() => {
      previewParse()
      previewTimer = null
    }, 400)
  }
)

const emojiStore = useEmojiStore()

// Antd dropdown already imported above

const onGroupSelect = (info: any) => {
  groupId.value = String(info.key)
}

const selectedGroupLabel = computed(() => {
  if (!groupId.value || groupId.value === 'ungrouped') {
    return 'üìù Êú™ÂàÜÁªÑË°®ÊÉÖ'
  }
  const list = (groups.value as any[]) || []
  const g = list.find((x: { id?: string }) => x.id === groupId.value) as any
  return g ? `${g.icon ? g.icon + ' ' : ''}${g.name}` : 'ÈÄâÊã©ÂàÜÁªÑ'
})

// ÂõæÁâáÂä†ËΩΩÁä∂ÊÄÅ
const imageLoadError = ref(false)

function handleImageLoad() {
  imageLoadError.value = false
}

function handleImageError() {
  imageLoadError.value = true
}

const handleParsedImageError = (event: Event) => {
  const target = event.target as HTMLImageElement
  target.src = ''
}

const parseMarkdownImages = (text: string): ImageVariant[] => {
  const items: ImageVariant[] = []
  if (!text) return items
  const re = /!\[([^\]]*)\]\(([^)]+)\)/g
  let match: RegExpExecArray | null = null
  while ((match = re.exec(text)) !== null) {
    const alt = (match[1] || '').trim()
    let urlRaw = (match[2] || '').trim()
    // strip optional title after space: (url "title")
    urlRaw = urlRaw
      .split(/\s+/)[0]
      .replace(/^['"]|['"]$/g, '')
      .trim()
    const namePart = (alt || '').split('|')[0].trim()
    const nameVal =
      namePart || decodeURIComponent((urlRaw.split('/').pop() || '').split('?')[0]) || 'Êú™ÂëΩÂêç'
    const item = reactive({
      name: nameVal,
      url: urlRaw,
      variants: [{ label: 'ÈªòËÆ§', url: urlRaw }],
      selectedVariant: urlRaw
    })
    items.push(item)
  }
  return items
}

interface ImageVariant {
  name: string
  url: string
  variants: Array<{ label: string; url: string }>
  selectedVariant: string
  displayUrl?: string
}

const parseHTMLImages = (text: string): ImageVariant[] => {
  const items: ImageVariant[] = []
  if (!text) return items
  try {
    const parser = new DOMParser()
    const doc = parser.parseFromString(text, 'text/html')

    // prefer lightbox wrappers
    const lightboxWrappers = Array.from(doc.querySelectorAll('.lightbox-wrapper')) as HTMLElement[]
    if (lightboxWrappers.length) {
      lightboxWrappers.forEach(wrapper => {
        const anchor = wrapper.querySelector('a.lightbox') as HTMLAnchorElement | null
        const img = wrapper.querySelector('img') as HTMLImageElement | null

        if (!anchor || !img) return

        const title = anchor.getAttribute('title') || ''
        const originalUrl = anchor.getAttribute('href') || ''
        const downloadUrl = anchor.getAttribute('data-download-href') || ''
        const imgSrc = img.getAttribute('src') || ''
        const srcset = img.getAttribute('srcset') || ''

        const nameVal =
          title ||
          img.getAttribute('alt') ||
          decodeURIComponent((originalUrl.split('/').pop() || '').split('?')[0]) ||
          'Êú™ÂëΩÂêç'

        const variants: Array<{ label: string; url: string }> = []

        // Ê∑ªÂä†ÂéüÂßã URLÔºàÊúÄÈ´òË¥®ÈáèÔºâ
        if (originalUrl) {
          variants.push({ label: 'ÂéüÂßã (ÊúÄÈ´òË¥®Èáè)', url: originalUrl })
        }

        // Ê∑ªÂä†‰∏ãËΩΩ URL
        if (downloadUrl && downloadUrl !== originalUrl) {
          variants.push({ label: '‰∏ãËΩΩÈìæÊé•', url: downloadUrl })
        }

        // Ëß£Êûê srcset ‰∏≠ÁöÑÂèòÁßç
        if (srcset) {
          const srcsetParts = srcset.split(',').map(s => s.trim())
          srcsetParts.forEach(part => {
            const [url, descriptor] = part.split(' ')
            if (url && descriptor) {
              const scale = descriptor.replace('x', '')
              // Â∞ùËØï‰ªé URL ‰∏≠ÊèêÂèñÂ∞∫ÂØ∏‰ø°ÊÅØ
              const sizeMatch = url.match(/_(\d+)x(\d+)\./)
              const sizeInfo = sizeMatch ? ` (${sizeMatch[1]}√ó${sizeMatch[2]})` : ''
              variants.push({
                label: `${scale}x Áº©Êîæ${sizeInfo}`,
                url: url.startsWith('http')
                  ? url
                  : originalUrl
                    ? new URL(url, originalUrl).href
                    : url
              })
            }
          })
        }

        // Ê∑ªÂä†ÂΩìÂâçÊòæÁ§∫ÁöÑÂõæÁâá URL
        if (imgSrc && !variants.some(v => v.url === imgSrc)) {
          const sizeMatch = imgSrc.match(/_(\d+)x(\d+)\./)
          const sizeInfo = sizeMatch ? ` (${sizeMatch[1]}√ó${sizeMatch[2]})` : ''
          variants.push({
            label: `ÂΩìÂâçÊòæÁ§∫${sizeInfo}`,
            url: imgSrc.startsWith('http')
              ? imgSrc
              : originalUrl
                ? new URL(imgSrc, originalUrl).href
                : imgSrc
          })
        }

        if (variants.length > 0) {
          // ‰ºòÂÖàÈÄâÊã© GIFÔºàÂä®ÁîªÔºâÂèòÁßçÔºåÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØù
          const gifIndex = variants.findIndex(v => /(^data:image\/gif)|\.gif(\?|$)/i.test(v.url))
          if (gifIndex > 0) {
            const [gif] = variants.splice(gifIndex, 1)
            variants.unshift(gif)
          }
          // url Â∫î‰∏∫ÂéüÂßãÈìæÊé•Ôºàanchor hrefÔºâÔºådisplayUrl Áî®‰∫éÁº©Áï•ÂõæÂ±ïÁ§∫ÔºàimgSrcÔºâ
          const original = originalUrl || variants[0].url
          const displaySrc = imgSrc || variants[0].url
          const item = reactive({
            name: nameVal,
            url: original, // ‰øùÊåÅ url ‰∏∫ÂéüÂßãËµÑÊ∫êÈìæÊé•
            variants,
            selectedVariant: variants[0].url,
            displayUrl: displaySrc
          })
          items.push(item)
        }
      })
      return items
    }

    // prefer anchors with class lightbox (ÂÖºÂÆπÊóßÊ†ºÂºè)
    const anchors = Array.from(doc.querySelectorAll('a.lightbox')) as HTMLAnchorElement[]
    if (anchors.length) {
      anchors.forEach(a => {
        const title = a.getAttribute('title') || ''
        const img = a.querySelector('img') as HTMLImageElement | null
        const href = (
          a.getAttribute('href') ||
          a.getAttribute('data-download-href') ||
          (img && img.src) ||
          ''
        ).trim()
        const nameVal =
          title ||
          (img && img.alt) ||
          decodeURIComponent((href.split('/').pop() || '').split('?')[0]) ||
          'Êú™ÂëΩÂêç'

        const variants: Array<{ label: string; url: string }> = []
        if (href) variants.push({ label: 'ÈªòËÆ§', url: href })

        if (href) {
          // Â¶ÇÊûú href ÊåáÂêë GIFÔºåÂàô‰ºòÂÖà
          const gifIndex = variants.findIndex(v => /(^data:image\/gif)|\.gif(\?|$)/i.test(v.url))
          if (gifIndex > 0) {
            const [gif] = variants.splice(gifIndex, 1)
            variants.unshift(gif)
          }
          // url ‰ΩøÁî® hrefÔºàÂéüÂßãÈìæÊé•ÔºâÔºådisplayUrl ‰ºòÂÖà‰ΩøÁî®ÂÜÖÂµå img ÁöÑ srcÔºàÈ°µÈù¢‰∏äÊòæÁ§∫ÁöÑÂõæÁâáÔºâ
          const displaySrc = (img && img.src) || href
          const item = reactive({
            name: nameVal,
            url: href,
            variants,
            selectedVariant: variants[0].url,
            displayUrl: displaySrc
          })
          items.push(item)
        }
      })
      return items
    }

    // fallback: parse img tags
    const imgs = Array.from(doc.querySelectorAll('img')) as HTMLImageElement[]
    imgs.forEach(img => {
      const src = (img.getAttribute('src') || '').trim()
      const alt = img.getAttribute('alt') || ''
      const nameVal =
        alt || decodeURIComponent((src.split('/').pop() || '').split('?')[0]) || 'Êú™ÂëΩÂêç'

      const variants: Array<{ label: string; url: string }> = []
      if (src) variants.push({ label: 'ÈªòËÆ§', url: src })

      if (src) {
        // Â¶ÇÊûú src ÊòØ GIF Êàñ data:image/gifÔºåÂàôÁ°Æ‰øùÂÆÉÂú®È¶ñ‰Ωç
        const gifIndex = variants.findIndex(v => /(^data:image\/gif)|\.gif(\?|$)/i.test(v.url))
        if (gifIndex > 0) {
          const [gif] = variants.splice(gifIndex, 1)
          variants.unshift(gif)
        }
        const item = reactive({
          name: nameVal,
          url: src,
          variants,
          selectedVariant: variants[0].url,
          displayUrl: src
        })
        items.push(item)
      }
    })
  } catch {
    // parsing failed, return empty
  }
  return items
}

const previewParse = () => {
  let newItems: ImageVariant[] = []
  if (inputMode.value === 'markdown') {
    newItems = parseMarkdownImages(pasteText.value)
  } else if (inputMode.value === 'html') {
    newItems = parseHTMLImages(pasteText.value)
  }

  // ‰øùÊåÅÁé∞ÊúâÈ°πÁõÆÁöÑ selectedVariant ÂÄºÔºåÂ¶ÇÊûúÂêçÁß∞Âíå URL ÂåπÈÖçÁöÑËØù
  const existingItems = parsedItems.value

  // Ê∏ÖÁ©∫Êï∞ÁªÑ‰ΩÜ‰øùÊåÅÂìçÂ∫îÊÄß
  parsedItems.value.splice(0)

  // Ê∑ªÂä†Êñ∞È°πÁõÆÔºåÂ∞ùËØï‰øùÊåÅ‰πãÂâçÁöÑÈÄâÊã©
  newItems.forEach(newItem => {
    const existingItem = existingItems.find(
      existing => existing.name === newItem.name && existing.url === newItem.url
    )

    if (existingItem && newItem.variants.some(v => v.url === existingItem.selectedVariant)) {
      // ‰øùÊåÅ‰πãÂâçÁöÑÈÄâÊã©
      newItem.selectedVariant = existingItem.selectedVariant
    }

    parsedItems.value.push(newItem)
  })
}

const setItemSelectedVariant = (item: ImageVariant, info: { key: string | number }) => {
  const val = String(info.key)
  item.selectedVariant = val
  // Ê†πÊçÆÂÖ®Â±ÄËÆæÁΩÆÂÜ≥ÂÆöÊòØÂê¶ÂêåÊ≠•ÊâÄÈÄâÂèò‰ΩìÂà∞ displayUrl
  const shouldSync = !!(emojiStore.settings && (emojiStore.settings as any).syncVariantToDisplayUrl)
  if (shouldSync) {
    // always set displayUrl when enabled (if it's a valid http(s) URL)
    if (/^https?:\/\//i.test(val)) {
      item.displayUrl = val
    }
  } else {
    // conservative behavior: only populate displayUrl if it's currently empty
    if ((!item.displayUrl || item.displayUrl === '') && /^https?:\/\//i.test(val)) {
      item.displayUrl = val
    }
  }
}

const close = () => {
  emits('update:show', false)
}

const add = () => {
  // If non-url mode, use already parsed items
  if (inputMode.value !== 'url') {
    return importParsed()
  }

  if (!name.value.trim() || !url.value.trim()) return
  // ÂÖÅËÆ∏Êú™ÂàÜÁªÑË°®ÊÉÖÔºàgroupId ‰∏∫Á©∫Êàñ 'ungrouped'Ôºâ
  const targetGroupId = groupId.value || 'ungrouped'
  const emojiData = {
    packet: Date.now(),
    name: name.value.trim(),
    url: url.value.trim(),
    ...(displayUrl.value.trim() && { displayUrl: displayUrl.value.trim() })
  }
  emojiStore.addEmoji(targetGroupId, emojiData)
  // IndexedDB removed: flushBuffer not needed
  emits('added', { groupId: targetGroupId, name: emojiData.name })
  emits('update:show', false)
  name.value = ''
  url.value = ''
  displayUrl.value = ''
  groupId.value = groups.value?.[0]?.id || ''
}

const importParsed = () => {
  if (parsedItems.value.length === 0) return
  // ÂÖÅËÆ∏Êú™ÂàÜÁªÑË°®ÊÉÖÔºàgroupId ‰∏∫Á©∫Êàñ 'ungrouped'Ôºâ
  const targetGroupId = groupId.value || 'ungrouped'
  emojiStore.beginBatch()
  try {
    parsedItems.value.forEach(it => {
      // Always use original URL for emoji.url
      const originalUrl = it.url
      // For display, prefer the selectedVariant (what user chose), then parsed displayUrl
      const displayForEmoji =
        it.selectedVariant && it.selectedVariant !== originalUrl
          ? it.selectedVariant
          : it.displayUrl || undefined

      const emojiData: any = {
        packet: Date.now(),
        name: it.name,
        url: originalUrl
      }
      if (displayForEmoji) emojiData.displayUrl = displayForEmoji

      emojiStore.addEmojiWithoutSave(targetGroupId, emojiData)
      emits('added', { groupId: targetGroupId, name: emojiData.name })
    })
    // IndexedDB removed: flushBuffer not needed
  } finally {
    void emojiStore.endBatch()
  }
  pasteText.value = ''
  parsedItems.value = []
  emits('update:show', false)
}
</script>

<template>
  <div
    v-if="show"
    class="fixed inset-0 z-50 overflow-y-auto"
    aria-labelledby="modal-title"
    role="dialog"
    aria-modal="true"
  >
    <transition name="overlay-fade">
      <div class="fixed inset-0 bg-gray-500 bg-opacity-75" @click="close"></div>
    </transition>

    <div class="flex items-center justify-center min-h-screen p-4">
      <transition name="card-pop" appear>
        <ACard
          hoverable
          style="max-width: 90vw; width: 900px; max-height: 90vh; overflow-y: auto"
          @click.stop
        >
          <div class="flex flex-col gap-6">
            <!-- ‰∏äÊñπÁºñËæëÂå∫ -->
            <div class="w-full">
              <div class="mb-4">
                <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">Ê∑ªÂä†Ë°®ÊÉÖ</h2>
                <div class="text-sm text-gray-500 dark:text-gray-400">
                  {{
                    inputMode === 'url'
                      ? 'Âçï‰∏™Ë°®ÊÉÖÊ®°Âºè'
                      : `ÊâπÈáèÊ®°Âºè (Â∑≤Ëß£ÊûêÔºö${parsedItems.length} ‰∏™)`
                  }}
                </div>
              </div>
              <form @submit.prevent="add" class="space-y-4">
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1 dark:text-white">
                    ËæìÂÖ•Ê®°Âºè
                  </label>
                  <div>
                    <a-tabs v-model:activeKey="inputMode" type="card">
                      <a-tab-pane key="url" tab="Âçï‰∏™ URL" />
                      <a-tab-pane key="markdown" tab="Markdown (ÊâπÈáè)" />
                      <a-tab-pane key="html" tab="HTML (ÊâπÈáè)" />
                    </a-tabs>
                    <div class="text-xs text-gray-500 mt-1">
                      Â∑≤Ëß£ÊûêÔºö{{ parsedItems.length }} ‰∏™
                    </div>
                  </div>
                </div>

                <div v-if="inputMode === 'url'">
                  <label class="block text-sm font-medium text-gray-700 mb-1 dark:text-white">
                    Ë°®ÊÉÖÂêçÁß∞
                  </label>
                  <input
                    v-model="name"
                    type="text"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-black dark:text-white dark:border-gray-600"
                    placeholder="ËæìÂÖ•Ë°®ÊÉÖÂêçÁß∞"
                  />
                </div>
                <div v-if="inputMode === 'url'">
                  <label class="block text-sm font-medium text-gray-700 mb-1 dark:text-white">
                    ËæìÂá∫ÈìæÊé• (ÂøÖÂ°´)
                  </label>
                  <input
                    v-model="url"
                    type="url"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-black dark:text-white dark:border-gray-600"
                    placeholder="ÊèíÂÖ•Âà∞ÁºñËæëÂô®Êó∂‰ΩøÁî®ÁöÑÈìæÊé•"
                  />
                  <label class="block text-sm font-medium text-gray-700 mb-1 mt-3 dark:text-white">
                    ÊòæÁ§∫ÈìæÊé• (ÂèØÈÄâ)
                  </label>
                  <input
                    v-model="displayUrl"
                    type="url"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-black dark:text-white dark:border-gray-600"
                    placeholder="Ë°®ÊÉÖÈÄâÊã©Âô®‰∏≠ÊòæÁ§∫ÁöÑÈìæÊé•ÔºåÁïôÁ©∫Âàô‰ΩøÁî®ËæìÂá∫ÈìæÊé•"
                  />
                </div>
                <div v-else>
                  <label class="block text-sm font-medium text-gray-700 mb-1 dark:text-white">
                    Á≤òË¥¥ÂÜÖÂÆπ (Markdown Êàñ HTML)
                  </label>
                  <div class="space-y-2">
                    <textarea
                      v-model="pasteText"
                      rows="6"
                      class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-black dark:text-white dark:border-gray-600"
                      :placeholder="
                        inputMode === 'markdown'
                          ? 'Á≤òË¥¥ Markdown ÂõæÁâáÔºåÂ¶Ç ![name|512x512](url)...'
                          : 'Á≤òË¥¥ HTML ÁâáÊÆµ (‰æãÂ¶Ç discourse lightbox ÁöÑ HTML)'
                      "
                    ></textarea>

                    <div class="flex items-center justify-between mt-2">
                      <div class="flex items-center gap-3">
                        <label class="flex items-center text-xs text-gray-500 dark:text-gray-400">
                          <input type="checkbox" v-model="autoPreview" class="mr-1" />
                          Ëá™Âä®È¢ÑËßà
                        </label>
                        <div class="text-xs text-gray-500">
                          È¢ÑËßà‰ºöËß£ÊûêÂá∫Ôºö{{ parsedItems.length }} ‰∏™
                        </div>
                      </div>
                      <div class="flex gap-2">
                        <a-button
                          @click="((pasteText = ''), (parsedItems = []))"
                          type="button"
                          class="px-3 py-1 text-xs bg-gray-100 dark:bg-gray-700 rounded"
                        >
                          Ê∏ÖÁ©∫ÂÜÖÂÆπ
                        </a-button>
                        <a-button
                          @click="previewParse"
                          type="button"
                          class="px-3 py-1 text-xs bg-gray-100 dark:bg-gray-700 rounded"
                        >
                          È¢ÑËßà
                        </a-button>
                        <a-button
                          @click="importParsed"
                          type="button"
                          class="px-3 py-1 text-xs bg-blue-600 text-white rounded"
                        >
                          ÂØºÂÖ•Ëß£ÊûêÈ°π
                        </a-button>
                      </div>
                    </div>
                  </div>
                </div>
                <div>
                  <label class="block text-sm font-medium text-gray-700 mb-1 dark:text-white">
                    ÊâÄÂ±ûÂàÜÁªÑ
                  </label>
                  <a-dropdown>
                    <template #overlay>
                      <a-menu @click="onGroupSelect">
                        <a-menu-item key="ungrouped" value="ungrouped">üìù Êú™ÂàÜÁªÑË°®ÊÉÖ</a-menu-item>
                        <a-menu-divider />
                        <a-menu-item v-for="g in groups" :key="g.id" :value="g.id" :title="g.id">
                          <a-image
                            v-if="g.icon && g.icon.startsWith('https://')"
                            :src="g.icon"
                            class="inline-block mr-1"
                            style="max-width: 10px"
                          />
                          <span v-else class="inline-block mr-1">{{ g.icon }}</span>
                          {{ g.name }}
                        </a-menu-item>
                      </a-menu>
                    </template>
                    <a-button class="dark:text-white dark:bg-gray-800">
                      {{ selectedGroupLabel }}
                      <DownOutlined />
                    </a-button>
                  </a-dropdown>
                </div>

                <!-- ÊåâÈíÆÂå∫Âüü -->
                <div class="mt-6 space-y-3">
                  <!-- Save and Cancel buttons -->
                  <div class="grid grid-cols-2 gap-3">
                    <a-button
                      type="button"
                      @click="add"
                      class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:text-sm"
                    >
                      {{ inputMode === 'url' ? 'Ê∑ªÂä†' : 'ÂØºÂÖ•Ëß£ÊûêÈ°π' }}
                    </a-button>
                    <a-button
                      type="button"
                      @click="close"
                      class="w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:text-sm dark:bg-black dark:text-white dark:border-gray-600"
                    >
                      ÂèñÊ∂à
                    </a-button>
                  </div>
                </div>
              </form>
            </div>

            <!-- ‰∏ãÊñπÈ¢ÑËßàÂå∫ -->
            <div class="w-full">
              <!-- ÂçïÂõæÈ¢ÑËßà (URL Ê®°Âºè) -->
              <div
                v-if="inputMode === 'url'"
                class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 border border-gray-200 dark:border-gray-700"
              >
                <h4 class="text-sm font-medium text-gray-700 dark:text-white mb-3">ÂõæÁâáÈ¢ÑËßà</h4>
                <div class="flex items-center justify-center min-h-48">
                  <!-- Êúâ URL ‰∏îÊú™Âá∫ÈîôÊó∂ÊòæÁ§∫ÂõæÁâá -->
                  <a-image
                    v-if="(displayUrl || url) && !imageLoadError"
                    :src="displayUrl || url"
                    class="object-contain w-full h-full max-h-96 rounded-lg border"
                    style="max-width: 500px"
                    @load="handleImageLoad"
                    @error="handleImageError"
                  />

                  <!-- URL ‰∏∫Á©∫Êó∂ÁöÑÂç†‰ΩçÁ¨¶ -->
                  <div
                    v-else-if="!displayUrl && !url"
                    class="flex items-center justify-center bg-gray-100 dark:bg-gray-900 rounded-lg border border-dashed border-gray-300 dark:border-gray-600 h-48 w-full"
                  >
                    <div class="text-center text-gray-500 dark:text-gray-400">
                      <div class="text-4xl mb-2">üñºÔ∏è</div>
                      <div class="text-sm">ËØ∑ËæìÂÖ•ÂõæÁâáÈìæÊé•</div>
                    </div>
                  </div>

                  <!-- ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•Êó∂ÁöÑÂç†‰ΩçÁ¨¶ -->
                  <div
                    v-else-if="imageLoadError"
                    class="flex items-center justify-center bg-gray-100 dark:bg-gray-900 rounded-lg border border-dashed border-gray-300 dark:border-gray-600 h-48 w-full"
                  >
                    <div class="text-center text-gray-500 dark:text-gray-400">
                      <div class="text-4xl mb-2">üì∑</div>
                      <div class="text-sm">ÂõæÁâáÂä†ËΩΩÂ§±Ë¥•</div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- ÊâπÈáèËß£ÊûêÁªìÊûúÈ¢ÑËßàÂíå URL ÂèòÁßçÈÄâÊã© -->
              <div
                v-if="parsedItems.length > 0 && inputMode !== 'url'"
                class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 border border-gray-200 dark:border-gray-700"
              >
                <div class="flex items-center justify-between mb-3">
                  <h4 class="text-sm font-medium text-gray-700 dark:text-white">
                    Ëß£ÊûêÁªìÊûú ({{ parsedItems.length }} ‰∏™)
                  </h4>
                  <a-button
                    @click="parsedItems = []"
                    type="button"
                    class="text-xs text-gray-500 hover:text-gray-700"
                  >
                    Ê∏ÖÁ©∫
                  </a-button>
                </div>
                <div class="max-h-96 overflow-y-auto">
                  <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                    <ACard
                      v-for="(item, index) in parsedItems"
                      :key="index"
                      hoverable
                      class="p-2 bg-white dark:bg-gray-900 rounded border dark:border-gray-700 flex flex-col items-stretch"
                    >
                      <!-- Image on top -->
                      <div class="flex items-center justify-center pb-2">
                        <a-image
                          :src="item.displayUrl || item.url"
                          :alt="item.name"
                          class="w-full h-32 object-contain rounded border"
                          @error="handleParsedImageError"
                          preview
                        />
                      </div>

                      <!-- Name (multi-line) -->
                      <div class="mt-2">
                        <textarea
                          v-model="item.name"
                          rows="2"
                          class="w-full px-2 py-1 border border-gray-200 dark:border-gray-700 rounded text-sm bg-white dark:bg-gray-900 dark:text-white resize-none break-words whitespace-normal"
                        ></textarea>
                      </div>

                      <!-- Variant select -->
                      <div class="mt-2">
                        <div v-if="item.variants.length > 1">
                          <a-dropdown>
                            <template #overlay>
                              <a-menu @click="onVariantSelectForItem(index, $event)">
                                <a-menu-item
                                  v-for="variant in item.variants"
                                  :key="variant.url"
                                  :value="variant.url"
                                >
                                  {{ variant.label }}
                                </a-menu-item>
                              </a-menu>
                            </template>
                            <a-button class="text-xs w-full flex items-center justify-between">
                              <span>
                                {{
                                  item.variants.find(v => v.url === item.selectedVariant)?.label ||
                                  'ÈªòËÆ§'
                                }}
                              </span>
                              <DownOutlined />
                            </a-button>
                          </a-dropdown>
                        </div>
                        <div v-else class="text-xs text-gray-500 mt-1">
                          {{ item.variants[0]?.label || 'ÈªòËÆ§' }}
                        </div>
                        <div class="mt-1 text-xs text-gray-500 dark:text-gray-400 break-all">
                          {{ item.selectedVariant || item.url }}
                        </div>
                      </div>

                      <!-- Delete button at bottom right -->
                      <div class="mt-3 flex justify-end">
                        <a-button type="text" class="text-red-500" @click="removeParsedItem(index)">
                          <DeleteOutlined />
                        </a-button>
                      </div>
                    </ACard>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </ACard>
      </transition>
    </div>
  </div>
</template>

<style scoped>
/* overlay fade */
.overlay-fade-enter-from,
.overlay-fade-leave-to {
  opacity: 0;
}
.overlay-fade-enter-active,
.overlay-fade-leave-active {
  transition: opacity 220ms cubic-bezier(0.4, 0, 0.2, 1);
}

/* card pop: fade + slight translate + scale */
.card-pop-enter-from {
  opacity: 0;
  transform: translateY(12px) scale(0.98);
}
.card-pop-enter-to {
  opacity: 1;
  transform: translateY(0) scale(1);
}
.card-pop-leave-from {
  opacity: 1;
  transform: translateY(0) scale(1);
}
.card-pop-leave-to {
  opacity: 0;
  transform: translateY(8px) scale(0.98);
}
.card-pop-enter-active,
.card-pop-leave-active {
  transition:
    opacity 220ms cubic-bezier(0.4, 0, 0.2, 1),
    transform 220ms cubic-bezier(0.4, 0, 0.2, 1);
}
</style>
